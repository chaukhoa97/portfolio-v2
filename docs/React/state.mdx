---
title: 'State'
---

import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

## Pre-existing _inputs_

These are 3 kinds of _"inputs"_ that you can read while rendering. **You should always treat these inputs as read-only.**

### Props

The object passed to the function component, **included children**. Props are like arguments you pass to a function. **They let a parent component pass data to a child component and customize its appearance**. For example, a `Form` can pass a `color` prop to a `Button`.

### State

State is like a component’s memory. **It lets a component keep track of some information and change it in response to interactions**. For example, a `Button` might keep track of `isHovered` state.

### Context

Context lets components pass information deep down without explicitly passing props.

<Tabs>
  <TabItem value="UIContext" label="components/ui/UIContext.ts" >

```ts
import { createContext, useContext } from 'react'

export type Currency = 'USD' | 'VND'

export interface UIContextProps {
  currency: Currency
  setCurrency: (currency: Currency) => void
}

const UIContext = createContext<UIContextProps>({
  currency: 'USD',
  setCurrency: () => {},
})

export default UIContext

// B1': Export Hook that returns Context value to use in component -> Clean code
export const useUI = () => {
  const { currency, setCurrency } = useContext(UIContext)
  return { currency, setCurrency }
}
```

  </TabItem>
  <TabItem value="_app" label="_app.tsx">

```tsx
import type { AppProps } from 'next/app'
import { useState } from 'react'
import Layout from '../components/Layout'
import type { Currency } from '../components/ui/UIContext'
import UIContext from '../components/ui/UIContext'

function MyApp({ Component, pageProps }: AppProps) {
  // To update context, you need to combine it with state.
  const [currency, setCurrency] = useState<Currency>('USD')
  const memoizedValue = useMemo(() => ({ currency, setCurrency }), [currency])

  return (
    // B2: Provide Context cho ~ part cần
    <UIContext.Provider value={memoizedValue}>
      <Layout>
        <Component {...pageProps} />
      </Layout>
    </UIContext.Provider>
  )
}

export default MyApp
```

  </TabItem>
  <TabItem value="SomeComponent" label="SomeComponent.tsx">

```js
import { useContext } from 'react'
import UIContext, { useUI } from './NumberContext'

// B3: Use Context
const { currency, setCurrency } = useContext(UIContext)
// Hoặc
const { currency, setCurrency } = useUI() // B1': Clean code, chỉ cần import `useUI` là đủ
```

  </TabItem>
</Tabs>

_Read more_: [Kết hợp giữa `useReducer` và `Context` để manage **wide** sate](https://beta.reactjs.org/learn/scaling-up-with-reducer-and-context)

### Local mutation

Pure functions don’t mutate variables outside of the function’s scope or objects that were created before the call — that makes them impure!  
However, **it’s completely fine to change variables and objects that you’ve _just_ created while rendering**. In this example, you create an `[]` array, assign it to a `cups` variable, and then `push` a dozen cups into it:

```jsx
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>
}

export default function TeaGathering() {
  let cups = []
  for (let i = 1; i <= 12; i++) {
    cups.push(<Cup key={i} guest={i} />)
  }
  return cups
}
```

If the `cups` variable or the `[]` array were created outside the `TeaGathering` function, this would be a huge problem! You would be changing a preexisting object by pushing items into that array.  
However, it’s fine because you’ve created them **during the same _render_ ([_render_ nghĩa là call Component function - ở đây là call `TeaGathering`](react-lifecycle.md#step-1-react-trigger-render-initial-hoặc-re-render-component), với mỗi lần call thì `cups` dc tạo lại trong lần call đấy)**. No code outside of `TeaGathering` will ever know that this happened. This is called **“local mutation”** — it’s like your component’s little secret.

## Object & Array inputs

> You should treat _Pre-existing Variable_ as immutable!

Instead of mutating an object/array, create a new version of it, and trigger a re-render by setting state to it.

### Object

```jsx
const [person, setPerson] = useState({
  name: 'Niki de Saint Phalle',
  artwork: {
    title: 'Blue Nana',
    city: 'Hamburg',
    image: 'https://i.imgur.com/Sd1AgUOm.jpg',
  },
})

person.artwork.city = 'New Delhi' // ❌: Don't mutate state

// ✅: Create a new object and set the state to it
// If you want to update a nested property, you’ll have to use it more than once (bc `...` spread is "shallow" - it only copies things one level deep)
const nextArtwork = { ...person.artwork, city: 'New Delhi' }
const nextPerson = { ...person, artwork: nextArtwork }
setPerson(nextPerson)
```

### Array

|                                                                                                     | Avoid (mutates the array)           | Prefer (returns a new array)                                                                                               |
| --------------------------------------------------------------------------------------------------- | ----------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |
| [Adding](https://beta.reactjs.org/learn/updating-arrays-in-state#adding-to-an-array)                | `push`, `unshift`                   | `concat`, `[...arr]` spread syntax                                                                                         |
| [Removing](https://beta.reactjs.org/learn/updating-arrays-in-state#removing-from-an-array)          | `splice`, `pop`, `shift`            | `filter`, `slice`                                                                                                          |
| [Replacing](https://beta.reactjs.org/learn/updating-arrays-in-state#replacing-items-in-an-array)    | `splice`, `arr[i] = ...` assignment | `map`                                                                                                                      |
| [Sorting](https://beta.reactjs.org/learn/updating-arrays-in-state#making-other-changes-to-an-array) | `sort`, `reverse`                   | Copy the array first ([example](https://beta.reactjs.org/learn/updating-arrays-in-state#making-other-changes-to-an-array)) |

[_Unlike React, Vue is able to detect when a reactive array's mutation methods are called and trigger necessary updates._](https://vuejs.org/guide/essentials/list.html#array-change-detection)

#### Example: Inserting _at any position_ to an array

```jsx
const [artists, setArtists] = useState([])

function handleClick() {
  const insertAt = 1 // Could be any index
  const nextArtists = [
    // Items before the insertion point:
    ...artists.slice(0, insertAt),
    // New item:
    { id: nextId++, name: name },
    // Items after the insertion point:
    ...artists.slice(insertAt),
  ]
  setArtists(nextArtists)
}
```

## Managing State

### Preserving state

**Same component (`<section>`, `<p>`)+ Same position (`1st`, `2nd` element of the parent) &rarr; Preserves state.** It means the structure of your tree needs to “match up” from one render to another.

![Preserving state](https://beta.reactjs.org/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_same_pt1.dark.png&w=828&q=75)

### Resetting state at the same position

```jsx
// These 2 share the state
isPlayerA ? <Counter person="Taylor" /> : <Counter person="Sarah" />
```

#### Option 1: Rendering a component in different positions

```jsx
// These 2 won't share the state!
{
  isPlayerA && <Counter person="Taylor" />
}
{
  !isPlayerA && <Counter person="Sarah" />
}
```

#### Option 2: Resetting state with a key

```jsx
// These 2 won't share the state!
{
  isPlayerA ? (
    <Counter key="Taylor" person="Taylor" />
  ) : (
    <Counter key="Sarah" person="Sarah" />
  )
}
```
