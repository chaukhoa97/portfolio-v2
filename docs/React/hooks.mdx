---
title: 'Hooks'
---

import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

## `useEffect`

### A component must be pure

The component's _rendering code_ is where you take the props and state, transform them, and return the JSX you want to see on the screen. It must be **pure**, which means:

- It should not change any variables that existed before rendering.
- It should always return the same result when being given the same inputs, including props, state and context.

### Side effects

Anything that shouldn't happen during rendering, which means it can modify its own appearance or pre-existing variables is called **Side effect**. It can do more things rather than just calculate the JSX, e.g. (for example) it can modify a state value other than the initial value, toggle dark mode on the website, query more products from the server,...  
In React, side effects usually belong inside **event handlers**. They don’t need to be pure because even though they are defined inside your component, they **don’t** run in the rendering phase.

### Effects

**Effects** refers to the React-specific definition, i.e. _side effects_ caused by **rendering itself**, rather than **side effects** caused by a **particular event**, and therefore **can't** be handled by event handlers. For example, sending a message in the chat is an **Event** because it is directly caused by the user clicking a button. However, setting up a server connection is an **Effect** because it needs to happen regardless what makes the component to appear.

In React, effects are handled by `useEffect` hook. It let you run some code **after rendering** to synchronize React components with **external systems** outside of React. For example, you might want to set up a server connection, send an analytics log when a component appears on the screen, or control an external element based on a React state.

### Snippets

<Tabs>
  <TabItem value="Fetch & Use external value" label="Fetch & Use external value" >

```jsx
function App({ id }) {
  const [user, setUser] = useState()

  useEffect(() => {
    // Declare the function in Effect so it won't be called on every render
    const fetchUser = async () => {
      const result = await fetch(`https://users.com/[${id}]`)
      setUser(result)
    }
    fetchUser()
  }, [id])

  useEffect(() => {
    window.someAnalytics.push(user)
  }, [user])

  return <div>{user}</div>
}
```

  </TabItem>
  <TabItem value="setTimeout" label="Delay a value" >

```jsx
function useDelayedValue(value, delay) {
  const [delayedValue, setDelayedValue] = useState(value)

  // useEffect, setTimeout, setInterval đều có 1st param là callback
  useEffect(() => {
    setTimeout(() => {
      setDelayedValue(value)
    }, delay)
  }, [value, delay])

  return delayedValue
}
```

  </TabItem>
  <TabItem value="setInterval" label="setInterval for third party API" >

```jsx
function useInterval() {
  const [externalData, setExternalData] = useState()

  useEffect(() => {
    const tagalysInterval = setInterval(() => {
      if (window.Tagalys) {
        clearInterval(tagalysInterval)
        setExternalData(Tagalys.getData())
      }
    }, 100)
  }, [])

  return externalData
}
```

  </TabItem>
</Tabs>

### (Recommended) Thinking from the Effect’s perspective

The _Effect_ start `connecting` (until it `disconnect` when the `id` change), and then `connects` to another `id`...  
Finally when the `App` unmount, the _Effect_ `disconnect`.

### Thinking from the component’s perspective

- **Mounting**: Render &rarr; Commit &rarr; `useEffectCode`
- **Updating**: Render &rarr; Commit &rarr; `useEffectCode` &rarr; Rerender when deps change &rarr; `cleanUp` with **old** values &rarr; `useEffectCode` with **new** values...
- **Unmounting**: `cleanUp` (**AFTER** the component is removed from the DOM).

:::caution

Anything you use in your effect callback that has a _stable identity_ aren't necessary to be included the dependency array, e.g. `setState`, refs from `useRef` because you’ll always get the same object for those on every render.

:::

:::note

_Mount/ Unmount_ means Adding/ Removing nodes to the DOM.

- Ko cần cleanup (Chạy rồi thì k cần quan tâm nữa): Gọi API, Tương tác DOM.
- Cần cleanup: `setTimeout`/`setInterval`, connection to a server/database

:::

## Optimize

### `useCallback`

Memoize **function**: When the component re-render, the reference to the function in `useCallback` will be retained &rarr; Components that take the function as `props` won't re-render pointlessly.

:::note
If you’re writing a custom Hook, it’s recommended to wrap any functions that it returns into `useCallback` if you plan to pass them as Component `prop` or `useEffect` dependency.
:::

### `useMemo`

Memoize **return value of a function**: When the component re-render, the reference to the return value in `useMemo` callback will be retained &rarr; Components that take the return value as `props` won't re-render pointlessly. Or when the function that creates the value is too complex (ex: Sort, fetch,...).

It's also generally a good idea to memoize values of a [Context](./state.mdx#Context) because there might be dozens of pure components that consume this context. Without `useMemo`, all of these components would be forced to re-render if the `Context Provider` happens to re-render.

> **Read more**: `useMemo` [benchmark result](https://i.imgur.com/GZdPjKP.png)

:::note
`useCallback(someFunction, deps)` are the same with `useMemo(() => someFunction, deps)`
:::

`useMemo` can also be used to memoized a component:

```tsx
export const Page = ({ countries }: { countries: Country[] }) => {
  const [selectedCountry, setSelectedCountry] = useState<Country>(countries[0])
  const [savedCountry, setSavedCountry] = useState<Country>(countries[0])

  const list = useMemo(() => {
    return (
      <CountriesList
        countries={countries}
        onCountryChanged={(c) => setSelectedCountry(c)}
        // This helps CountriesList to NOT rerender when `selectedCountry` changes, because it's not used in CountriesList
        savedCountry={savedCountry}
      />
    )
  }, [savedCountry, countries])

  const selected = useMemo(() => {
    return (
      <SelectedCountry
        // This helps SelectedCountry to NOT rerender when `savedCountry` changes, because it's not used in SelectedCountry
        country={selectedCountry}
        onCountrySaved={() => setSavedCountry(selectedCountry)}
      />
    )
  }, [selectedCountry])

  return (
    <>
      <h1>Country settings</h1>
      <div css={contentCss}>
        {list}
        {selected}
      </div>
    </>
  )
}
```

### `React.memo`

Chỉ re-render component dc wrap bởi `React.memo` khi `props` của component thay đổi (using `useCallback` and `useMemo` in the parent component for values which are used as `props` can reduce their number of changes).  
Wrap `React.memo` correctly at high level components &rarr; các component ở dưới cũng sẽ ko bị re-render.

### Example for all of 3

```jsx
const Parent = () => {
  const someFunction = () => 'Some value'
  //1. Parent re-render, cachedFn do có useCallback ko bị create lại.
  const cachedFn = useCallback(someFunction, [])
  //2. prop của Children là cachedFn ko bị create lại...
  return <Children expensiveFn={cachedFn} />
}
export default Parent
```

```jsx
const Children = ({ todos, text }) => {
  const options = { searchParam: text } // Create lại mỗi lần Children re-render
  const uncachedTodos = filterTodos(todos, options) // Create lại mỗi lần Children re-render

  const cachedTodos = useMemo(() => {
    // Declare `options` in `useMemo` won't let it be re-created as `cachedTodos` ko bị create lại
    const options = { searchParam: text }
    return filterTodos(todos, options)
  }, [todos, text])

  return (
    <>
      {/* `uncachedTodos` là ref value -> `value` prop của Kid1 thay đổi mỗi khi Children re-render */}
      <Kid1 value={uncachedTodos} />
      {/* Chỉ khi `cachedTodos` thay đổi (khi `todos` và `text` thay đổi) thì `value` prop của Kid2 mới đổi */}
      <Kid2 value={cachedTodos} />
    </>
  )
}
//3. Children sẽ KO re-render khi Parent re-render do prop (ở đây là cachedFn) ko đổi
export default React.memo(Children)
```

## `useRef`

### Usage

Lets you reference a value that’s **NOT** needed for rendering. You should only use them when you have to “step outside React"

- Communicate with external APIs - often a browser API that won’t impact the appearance of the component (`focus`, `scrollIntoView`) &rarr; Storing and manipulating DOM elements.

- Storing and persisting other values that only needed by event handlers and changing it doesn’t require a re-render (it's NOT necessary for calculating the JSX), e.g. `timeoutId`, user input.

### Do not write or read `ref.current` during rendering

```jsx
function MyComponent() {
  // ...
  // ❌ Don't write a ref during rendering
  myRef.current = 123
  // ...
  // ❌ Don't read a ref during rendering
  return <h1>{myOtherRef.current}</h1>
}
```

You can read or write refs from event handlers or effects instead.

```jsx
function MyComponent() {
  // ...
  useEffect(() => {
    // ✅ You can read or write refs in effects
    myRef.current = 123
  })
  // ...
  function handleClick() {
    // ✅ You can read or write refs in event handlers
    doSomething(myOtherRef.current)
  }
  // ...
}
```

### `forwardRef`

```tsx
const MyButton = React.forwardRef(
  <HTMLButtonElement, ButtonProps>({ className, ...props }, ref) => {
    return <button className={className} ref={ref} />
  },
)

export default function App() {
  return <MyButton ref={buttonRef} />
}
```

1. `<MyButton ref={buttonRef}>` tells React to put the corresponding DOM node into `buttonRef.current`. However, it’s up to the `MyButton` component to opt into that. By default, it doesn’t.
1. The `MyButton` component is declared using `forwardRef`. This opts it into receiving the `buttonRef`.
1. `MyButton` itself passes the `ref` it received to the `<button>` inside of it.

### `useRef` vs `useState` vs `let`

|                                                            | `useRef` | `useState` | `let` |
| :--------------------------------------------------------: | :------: | :--------: | :---: |
|     Value is <u>preserved</u> khi Component re-render      |    ✅    |     ✅     |  ❌   |
|        Updating value requires Component re-render         |    ❌    |     ✅     |  ❌   |
| Value is <u>unique</u> for every instance of the Component |    ✅    |     ✅     |  ❌   |
|                          Mutable                           |    ✅    |     ❌     |  ✅   |

#### Kết luận

- `useState`: Values used for rendering, có thể thay đổi và ~ thay đổi đó require a re-render.
- `useRef`: Values <u>NOT</u> used for rendering, có thể thay đổi và ~ thay đổi đó do <u>NOT</u> require a re-render e.g. user's search box input, `timeoutId`.
- `JS variable`: Values <u>NOT</u> used for rendering, constant, can be shared among mutliple instances of the component e.g. `env` values.

### Snippet: Debounce button

```jsx
const timeoutRef = useRef(null);

<button onClick={() => {
  clearTimeout(timeoutRef.current);
  timeoutRef.current = setTimeout(() => {}, 1000);
}}>
```

### Snippet: One `ref` for a list of elements

```jsx
const [index, setIndex] = useState(0)
const selectedRef = useRef(null)
{
  cats.map((cat, i) => (
    <Cat
      key={cat.id}
      cat={cat}
      onClick={() => {
        setIndex(i)
      }}
      ref={index === i ? selectedRef : null}
    />
  ))
}
```

## `useState` & `useReducer`

### Usage & Comparison

Usage: Both are used to manage _Narrow State_. `useReducer` dùng cho ~ Narrow State mà có nhiều case.  
Use [`useContext`](./state#context) or [Redux](../Libraries/redux.md) for _Wide State_.

> **Read more**: [So sánh `useState` & `useReducer`](https://react.dev/learn/extracting-state-logic-into-a-reducer#comparing-usestate-and-usereducer).

### `useState`

A state variable’s value never changes within a render, even if its event handler’s code is asynchronous

```jsx
function Counter() {
  // Lazy init: `computeExpensiveValue` chỉ chạy ở lần render đầu tiên để tạo ra giá trị init cho `count` state
  const [count, setCount] = useState(() => computeExpensiveValue(a, b))

  const handleClick = () => {
    // Update dựa theo prev state, convention là letter đầu tiên (count -> c)
    setCount((c) => c + 5)
    // Alert 0 instead of 5 even though `count` changed to 5
    // Because `handleClick` function is a closure - it can only see the values of variables as they existed when the function was defined
    // In other words, these state variables were a snapshot at the time the button was clicked
    setTimeout(() => {
      alert(count)
    }, 1000)
  }

  return <button onClick={handleClick}>+5</button>
}
```

_[Demo CodeSanbox](https://codesandbox.io/s/state-as-snapshot-dtklvu?file=/App.js)_

### `useReducer`

```jsx
import { useReducer } from 'react'

const infoReducer = (state, action) => {
  switch (action.type) {
    case 'loading':
      return { loading: true }
    case 'success':
      return { ...action, loading: false }
    default:
      throw Error('Unknown action: ' + action.type)
  }
}

function ReducerExample() {
  const [info, dispatch] = useReducer(infoReducer, {
    loading: false,
    data: '',
  })
  const getInfo = () => {
    dispatch({ type: 'loading' }) // info = `state` line 3 = { loading: true, data: "", type: "loading" }
    setTimeout(() => {
      fetch('https://jsonplaceholder.typicode.com/todos/1')
        .then((response) => response.json())
        .then((json) => dispatch({ type: 'success', data: json })) // info = { loading: false, data: {...}, type: "success" }
    }, 1000)
  }

  return (
    <>
      {info.loading ? <h5>Loading...</h5> : <h5>{info.data.title}</h5>}
      <button onClick={getInfo}>Get data</button>
    </>
  )
}

export default ReducerExample
```

## Custom Hook

1. Let you share _stateful logic_ to React components but NOT the _state_ itself (Each component that uses the same Custom Hook will get its own isolated instance of state).
2. Better project structure by implementing the logic in a custom hook, then using them in View (UI/ Presentational/ Dumb) Components.

```jsx
// Custom hook MUST start with "use"
function useCounterUseCase({ required = 'default', ...rest }) {
  const [value, setValue] = useState(0)
  return { value, setValue }
}
```

```jsx
import useCounterUseCase from './useCounterUseCase.jsx'
function Container() {
  const { value, setValue } = useCounterUseCase({
    required: 'meo',
    optional1: '1',
    optional2: '2',
  })
}
```
