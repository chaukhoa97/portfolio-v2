---
title: 'Hooks'
---

import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

## `useEffect`

### A component must be pure

The component's _rendering code_ is where you take the props and state, transform them, and return the JSX you want to see on the screen. It must be **pure**, which means:

- It should not change any variables that existed before rendering.
- It should always return the same result when being given the same inputs, including props, state and context.

### Side effects

Anything that shouldn't happen during rendering, which means it can modify its own appearance or pre-existing variables is called **Side effect**. It can do more things rather than just calculate the JSX, e.g. (for example) it can modify a state value other than the initial value, toggle dark mode on the website, query more products from the server,...  
In React, side effects usually belong inside **event handlers**. They don’t need to be pure because even though they are defined inside your component, they **don’t** run in the rendering phase.

### Effects

**Effects** refers to the React-specific definition, i.e. _side effects_ caused by **rendering itself**, rather than **side effects** caused by a **particular event**, and therefore **can't** be handled by event handlers. For example, sending a message in the chat is an **Event** because it is directly caused by the user clicking a button. However, setting up a server connection is an **Effect** because it needs to happen regardless what makes the component to appear.  
In React, effects are handled by `useEffect` hook.

---

**Effects** let you run some code **after rendering** to synchronize React components with **external systems** outside of React (like a network or a third-party library). For example, you might want to set up a server connection, send an analytics log when a component appears on the screen, or control an external component based on a React state.

### Snippets

<Tabs>
  <TabItem value="Fetch & Use external value" label="Fetch & Use external value" >

```jsx
function App({ id }) {
  const [user, setUser] = useState()

  useEffect(() => {
    // Declare the function in Effect so it won't be called on every render
    const fetchUser = async () => {
      const result = await fetch(`https://users.com/[${id}]`)
      setUser(result)
    }
    fetchUser()
  }, [id])

  useEffect(() => {
    window.someAnalytics.push(user)
  }, [user])

  return <div>{user}</div>
}
```

  </TabItem>
  <TabItem value="setTimeout" label="Delay a value" >

```jsx
function useDelayedValue(value, delay) {
  const [delayedValue, setDelayedValue] = useState(value)

  // useEffect, setTimeout, setInterval đều có 1st param là callback
  useEffect(() => {
    setTimeout(() => {
      setDelayedValue(value)
    }, delay)
  }, [value, delay])

  return delayedValue
}
```

  </TabItem>
  <TabItem value="setInterval" label="setInterval for third party API" >

```jsx
function useInterval() {
  const [externalData, setExternalData] = useState()

  useEffect(() => {
    const tagalysInterval = setInterval(() => {
      if (window.Tagalys) {
        clearInterval(tagalysInterval)
        setExternalData(Tagalys.getData())
      }
    }, 100)
  }, [])

  return externalData
}
```

  </TabItem>
</Tabs>

### How it runs from the Effect’s perspective

The _Effect_ start `connecting` (until it `disconnect` when the `id` change), and then `connects` to another `id`...  
Finally when the `App` unmount, the _Effect_ `disconnect`.

### How it runs from the component’s perspective

- **Mounting**: Render &rarr; Commit &rarr; `useEffectCode`
- **Updating**: Render &rarr; Commit &rarr; `useEffectCode` &rarr; Rerun when deps change &rarr; `cleanUp` with **old** values &rarr; `useEffectCode` with **new** values...
- **Unmounting**: `cleanUp` (**AFTER** the component is removed from the DOM).

:::note

_Mount/Unmount_ means Adding/Removing nodes to the DOM.  
Ko cần cleanup (Chạy rồi thì k cần quan tâm nữa): Gọi API, Tương tác DOM.  
Cần cleanup: `setTimeout`/`setInterval`, connection to a server/database

:::

## Optimize

### `useCallback`

Memoize **function**: When the component re-render, the reference to the function in `useCallback` will be retained &rarr; Components that take the function as `props` won't re-render pointlessly.

:::note
If you’re writing a custom Hook, it’s recommended to wrap any functions that it returns into `useCallback` if you plan to pass them as Component `prop` or `useEffect` dependency.
:::

### `useMemo`

Memoize **return value of a function**: When the component re-render, the reference to the return value in `useMemo` callback will be retained &rarr; Components that take the return value as `props` won't re-render pointlessly. Or when the function that creates the value is too complex (ex: Sort, fetch,...).

It's also generally a good idea to memoize [Context](./state.mdx#Context) values because there might be dozens of pure components that consume this context. Without `useMemo`, all of these components would be forced to re-render if the `Context Provider` happens to re-render.

> **Read more**: `useMemo` benchmark [article](https://canimerge.com/should-you-really-use-usememo-in-react-lets-find-out/) & [result](https://i.imgur.com/GZdPjKP.png)

:::note
`useCallback(someFunction, deps)` are the same with `useMemo(() => someFunction, deps)`
:::

### `React.memo`

Chỉ re-render component dc wrap bởi `React.memo` khi `props` của component thay đổi (`useCallback`/`useMemo` can reduce the number of `props` change).  
Wrap `React.memo` correctly at high level components &rarr; các component ở dưới cũng sẽ ko bị re-render.

```jsx
const Parent = () => {
  const someFunction = () => 'Some value'
  //1. Parent re-render, cachedFn do có useCallback ko bị create lại.
  const cachedFn = useCallback(someFunction, [])
  //2. prop của Children là cachedFn ko bị create lại...
  return <Children expensiveFn={cachedFn} />
}
export default Parent
```

```jsx
const Children = ({ todos, text }) => {
  const options = { searchParam: text }
  const uncachedTodos = filterTodos(todos, options) // Create lại mỗi lần Children re-render

  const cachedTodos = useMemo(() => {
    // `options` là ref nhưng bọc trong `useMemo` thì vẫn ok, `cachedTodos` ko bị create lại
    const options = { searchParam: text }
    return filterTodos(todos, options)
  }, [todos, text])

  return (
    <>
      {/* `uncachedTodos` là ref value -> `value` prop của Kid1 thay đổi mỗi khi Children re-render */}
      <Kid1 value={uncachedTodos} />
      {/* Chỉ khi `cachedTodos` thay đổi (khi `todos` và `text` thay đổi) thì `value` prop của Kid2 mới đổi */}
      <Kid2 value={cachedTodos} />
    </>
  )
}
//3. Children sẽ KO re-render khi Parent re-render do prop (ở đây là cachedFn) ko đổi
export default React.memo(Children)
```

## `useRef`

### Usage

You should only use them when you have to “step outside React"

- Communicate with external APIs - often a browser API that won’t impact the appearance of the component (`focus`, `scrollIntoView`) &rarr; Storing and manipulating DOM elements.

- Storing and persisting other values that only needed by event handlers and changing it doesn’t require a re-render (it's NOT necessary for calculating the JSX), e.g. `timeoutId`, user input.

### Do not write or read `ref.current` during rendering

```jsx
function MyComponent() {
  // ...
  // ❌ Don't write a ref during rendering
  myRef.current = 123
  // ...
  // ❌ Don't read a ref during rendering
  return <h1>{myOtherRef.current}</h1>
}
```

You can read or write refs from event handlers or effects instead.

```jsx
function MyComponent() {
  // ...
  useEffect(() => {
    // ✅ You can read or write refs in effects
    myRef.current = 123
  })
  // ...
  function handleClick() {
    // ✅ You can read or write refs in event handlers
    doSomething(myOtherRef.current)
  }
  // ...
}
```

### `useRef` vs `useState` vs `let`

|                                           | `useRef` | `useState` | `let` |
| :---------------------------------------: | :------: | :--------: | :---: |
| Value dc preserve khi Component re-render |    ✅    |     ✅     |  ❌   |
|  Update value khiến Component re-render   |    ❌    |     ✅     |  ❌   |
|                  Mutable                  |    ✅    |     ❌     |  ✅   |

:::note

Vì vậy, value used for rendering thì dùng `useState`. Còn những thứ only needed by event handlers and changing it doesn’t require a re-render (Ex: user's `input`, `timeoutId`) thì dùng `useRef`. Những thứ constant ko show thì dùng `JS variable` như bình thường.

:::

### Snippet: Debounce button

```jsx
const timeoutRef = useRef(null);

<button onClick={() => {
  clearTimeout(timeoutRef.current);
  timeoutRef.current = setTimeout(() => {}, 1000);
}}>
```

### Snippet: One `ref` for a list of elements

```jsx
const [index, setIndex] = useState(0)
const selectedRef = useRef(null)
{
  cats.map((cat, i) => (
    <Cat
      key={cat.id}
      cat={cat}
      onClick={() => {
        setIndex(i)
      }}
      ref={index === i ? selectedRef : null}
    />
  ))
}
```

## `useState` & `useReducer`

### Usage & Comparison

Usage: Both are used to manage _Narrow State_. `useReducer` dùng cho ~ Narrow State mà có nhiều case.  
Use [`useContext`](./state#context) or [Redux](./redux.md) for _Wide State_.

> **Read more**: [So sánh `useState` & `useReducer`](https://beta.reactjs.org/learn/extracting-state-logic-into-a-reducer#comparing-usestate-and-usereducer).

### `useState`

A state variable’s value never changes within a render, even if its event handler’s code is asynchronous

```jsx
function Counter() {
  // Lazy init: `computeExpensiveValue` chỉ chạy ở lần render đầu tiên để tạo ra giá trị init cho `count` state

  const [count, setCount] = useState(() => computeExpensiveValue(a, b))
  return (
    <button
      onClick={() => {
        // Update dựa theo prev state, convention là letter đầu tiên của state (count -> c)
        setCount((c) => c + 5)
        // Alert 0 thay vì 5, `alert` ở đây đã nhận snapshot của `count` state ngay lúc click btn (0)
        // Sau đó dẫu `count` có thay đổi (0 -> 5) cũng k ảnh hưởng tới giá trị dc `alert`
        setTimeout(() => {
          alert(count)
        }, 1000)
      }}
    >
      +5
    </button>
  )
}
```

_[Demo CodeSanbox](https://codesandbox.io/s/state-as-snapshot-dtklvu?file=/App.js)_

### `useReducer`

```jsx
import { useReducer } from 'react'

const infoReducer = (state, action) => {
  switch (action.type) {
    case 'loading':
      return { loading: true }
    case 'success':
      return { ...action, loading: false }
    default:
      throw Error('Unknown action: ' + action.type)
  }
}

function ReducerExample() {
  const [info, dispatch] = useReducer(infoReducer, {
    loading: false,
    data: '',
  })
  const getInfo = () => {
    dispatch({ type: 'loading' }) // info = `state` line 3 = { loading: true, data: "", type: "loading" }
    setTimeout(() => {
      fetch('https://jsonplaceholder.typicode.com/todos/1')
        .then((response) => response.json())
        .then((json) => dispatch({ type: 'success', data: json })) // info = { loading: false, data: {...}, type: "success" }
    }, 1000)
  }

  return (
    <>
      {info.loading ? <h5>Loading...</h5> : <h5>{info.data.title}</h5>}
      <button onClick={getInfo}>Get data</button>
    </>
  )
}

export default ReducerExample
```

## Custom Hook

Custom Hooks let you share _stateful logic_ across React components but NOT _state_ itself (Each component that uses the same Custom Hook will get its own isolated instance of state).  
**Use case**: Handle logic ở CustomHook rồi truyền vào View (UI/ Presentational/ Dumb) Component

```jsx
// Custom hook MUST start with "use"
function useCounterUseCase({ required = 'default', ...rest }) {
  const [value, setValue] = useState(0)
  return { value, setValue }
}
```

```jsx
import useCounterUseCase from './useCounterUseCase.jsx'
function Container() {
  const { value, setValue } = useCounterUseCase({
    required: 'meo',
    optional1: '1',
    optional2: '2',
  })
}
```

## HOC

A Higher Order Component (HOC) contains certain logic that we want to apply to the another component that we pass as a parameter. After applying that logic, the HOC returns the element with the additional logic.  
HOCs can largely be replaced by Hooks as they can reduce the depth of the component tree and make the code more readable.
