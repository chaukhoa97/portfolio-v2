---
title: 'JavaScript Essentials'
sidebar_position: 1
---

## Event loop

1. Synchronously execute the script until the **Call Stack** (LIFO) is empty. Các hàm **async** vào **Call stack** thì dc di chuyển qua **Web api**. Ở **Web api** chạy async xong thì push callback vào **Task Queue**/ **Microtask Queue**.

2. Select the **oldest** callback from **Microtask Queue** (was added in ES6 to handle `Promise`) to push into **Call Stack** and execute it. Repeat until the **Microtask Queue** is empty. This is the **Event Loop**.

3. Do the same like step 2 with **Task Queue** (`setTimeout`).

![Event loop](https://i.imgur.com/E1AuR7A.png)

### Example: Test this snippet [here](https://www.jsv9000.app/)

```js
setTimeout(function a() {}, 500)
setTimeout(function b() {}, 0)
fetch('https://jsonplaceholder.typicode.com/todos/1').then(function c() {})
Promise.resolve().then(function d() {})
Promise.reject().catch(function e() {})
function f() {
  g()
}
function g() {}
f()
```

## Closure

Is the combination of a **Function** and its **Lexical environment** (_references_ to any other data from the outer scope that the function depends on). Closure of a function is created at the time it is declared.  
_You can think of a function to have its own **"private"** variable._

```js
function f1() {
  let x = 0 // Dc giữ lại trong closure
  let y = 0 // Dc dọn dẹp bởi garbage collector
  return function f2() {
    x += 2 // f2 truy cập dc variables ở outer scope, ở đây là `x`
    return x
  }
}
// execute `f1` returns `f2` -> result == f2
// -> Variables which are in f2's Closure sẽ dc giữ lại, ở đây là `x`
const result = f1()
result() // 2
result() // 4
console.log(x) // ❌ ReferenceError: Biến `x` chỉ dc sử dụng trong `f1``
```

### Tricky example

```js
// When using `var` in a `for` loop, the variable is hoisted to Global Scope.
for (var i = 0; i < 3; i++) {
  // There are 3 different `log` declaration here, which means there are 3 different Closures
  // With `var`, all 3 `log` access to the same global variable `i`, which after the loop, is 3.
  // With `let`, there is a different `i` in each `for` loop since it's Block Scope
  // Put differently, each `log` access to its own `i` (`i` is a part of `log` Closure).
  const log = () => console.log(i)
  setTimeout(log, 0)
}
```

## Hoisting

JavaScript Engine moves the function and variable **declarations** to the top of the current **scope**.  
_NOTE: [**scope** of `var` and `let` is different.](#var-let-const)_

```js
add(3, 4); //* returns 7
// Function declaration -> hoisting lên đầu
function add(num1, num2) {
  return num1 + num2;
}

// ❌ Function expression -> ko hoisting
subtract(7, 4); // ❌ Uncaught TypeError: subtract is not a function
var subtract = function (num1, num2) {
  return num1 - num2;
};
var x; // console.log(x) -> undefined
let y; // console.log(y) -> undefined
const z; // ERROR ngay bước init
```

## Callback

_Hàm_ dc truyền qua _argument_.
Usage: Gọi hàm khi có sự kiện xảy ra, thực hiện bất đồng bộ.

## `for...in` vs `for...of` + `in` keyword

```js
const arr = ['a', 'b', 'c']
const obj = { a: 1, b: 2, c: 3 }
// for...in(dex)
for (const i in arr) {
  console.log(i) // 0, 1, 2
}
for (const i in obj) {
  console.log(i) // a, b, c
  console.log(obj[i]) // 1, 2, 3
}
// `in` keyword
console.log(0 in arr) // true
console.log('a' in arr) // false (you must specify the index number, not the value at that index)
console.log('a' in obj) // true

// for...of(value)
for (const i of arr) {
  console.log(i) // 'a', 'b', 'c'
}
for (const i of obj) {
  console.log(i) // TypeError: obj is not iterable
}
```

## var let const

|         |      Scope       |  Hoisting + Init value   | Re-declare | Update |
| :-----: | :--------------: | :----------------------: | :--------: | :----: |
|  `var`  | Function/ Global |     ✅ (`undefined`)     |     ✅     |   ✅   |
|  `let`  |      Block       |     ✅ (`undefined`)     |     ❌     |   ✅   |
| `const` |      Block       | ✅ (MUST be initialized) |     ❌     |   ❌   |

### `var` function scope

```js
function exampleVar() {
  if (true) {
    var x = 1
  }
  console.log(x) // Output: 1 (due to hoisting - x in the if block is hoisted to the function scope)
}
```

### `var` global scope

```js
var globalVar = 10
// In browsers, you can also access it as a property of the global object (window)
console.log(window.globalVar)
```

### `const` examples

```js
const obj = {}
obj.foo = 'bar' // {foo : 'bar'}
obj.foo = 'bar2' // {foo : 'bar2'}

const ar = []
ar.push('foo') // ['foo']
ar.pop() // []
```

```js
const text = 'a'
text = 'b' // ❌ error - re-assigning
const text = 'c' // ❌ error - re-declaring

const obj = {}
obj = { key1: 'foo' } // ❌ error - re-assigning
const obj = { key1: 'foo' } // ❌ error - re-declaring
```

## Types

### Primitive

- string; number (`NaN` _vẫn_ đc tính là number, Infinity, -Infinity); boolean; undefined(`typeof undefined === "undefined"`).
- null (`typeof null === “object”`): Mặc dù behavior giống _primitive_ nhưng lại là _object_.
- Ít dùng: symbol; bigint.

### Reference

- `typeof === “object”`: Object; Array; Set
- `typeof === “function"`: Function
- Ít dùng: date; regexp; error; map; weakmap; weakset.

### Falsy values

`0, “”, false, null, undefined, NaN`

## `this` keyword

`this` references the OBJECT that is excecuting the current function

```js
const person = {
  foo: ['a', 'b', 'c'],

  test() {
    // `this` of a METHOD will be the OBJECT/CLASS that contains the method
    console.log(this) // `person` obj

    this.foo.map(function (item) {
      // `this` of a regular fn will be the `window` object in the browser (or `global` object in Node)
      console.log(this) // `window` obj
    })

    // the second arg of `map` - `thisArg` will be used as the `this` of the callback fn, in this case, `person` obj
    this.foo.map(function (item) {
      console.log(this) // `person` obj
    }, this)

    this.foo.map((item) => {
      // `this` of a regular ARROW fn will be the OBJECT that contains the method
      console.log(this) // `person` obj
    })
  },
}
person.test()
```

[CodeSandbox example](https://codesandbox.io/s/vanilla-js-ijfdx6?file=/src/this.js)

## ETC

- `==` - chỉ so value &rarr; null == undefined vs `===` - so luôn cả type
- ![Object.freeze vs .seal vs .preventExtensions ](https://imgur.com/SsK9doN.png)
- [Sự khác biệt map và weakmap](https://kieblog.vn/javascript-su-khac-biet-map-va-weakmap/)
